wedding20.py:4:1: E302 expected 2 blank lines, found 1
wedding20.py:4:15: W291 trailing whitespace
wedding20.py:7:1: W293 blank line contains whitespace
wedding20.py:8:31: E262 inline comment should start with '# '
wedding20.py:9:21: E225 missing whitespace around operator
wedding20.py:10:33: E262 inline comment should start with '# '
wedding20.py:11:80: E501 line too long (99 > 79 characters)
wedding20.py:14:1: W293 blank line contains whitespace
wedding20.py:15:29: E231 missing whitespace after ','
wedding20.py:15:41: E261 at least two spaces before inline comment
wedding20.py:15:80: E501 line too long (86 > 79 characters)
wedding20.py:16:56: W291 trailing whitespace
wedding20.py:19:80: E501 line too long (90 > 79 characters)
wedding20.py:21:20: E225 missing whitespace around operator
wedding20.py:22:1: W293 blank line contains whitespace
wedding20.py:23:15: E275 missing whitespace after keyword
wedding20.py:24:1: W293 blank line contains whitespace
wedding20.py:26:21: E225 missing whitespace around operator
wedding20.py:27:80: E501 line too long (91 > 79 characters)
wedding20.py:27:92: W291 trailing whitespace
wedding20.py:28:48: E261 at least two spaces before inline comment
wedding20.py:28:80: E501 line too long (91 > 79 characters)
wedding20.py:29:80: E501 line too long (102 > 79 characters)
wedding20.py:30:80: E501 line too long (85 > 79 characters)
wedding20.py:31:80: E501 line too long (104 > 79 characters)
wedding20.py:32:75: E261 at least two spaces before inline comment
wedding20.py:32:80: E501 line too long (122 > 79 characters)
wedding20.py:33:80: E501 line too long (85 > 79 characters)
wedding20.py:35:80: E501 line too long (136 > 79 characters)
wedding20.py:36:80: E501 line too long (88 > 79 characters)
wedding20.py:39:1: W293 blank line contains whitespace
wedding20.py:40:1: W293 blank line contains whitespace
wedding20.py:41:5: E303 too many blank lines (2)
wedding20.py:41:37: E261 at least two spaces before inline comment
wedding20.py:41:80: E501 line too long (86 > 79 characters)
wedding20.py:45:1: W293 blank line contains whitespace
wedding20.py:46:22: E225 missing whitespace around operator
wedding20.py:46:80: E501 line too long (94 > 79 characters)
wedding20.py:50:23: E225 missing whitespace around operator
wedding20.py:50:80: E501 line too long (112 > 79 characters)
wedding20.py:52:80: E501 line too long (100 > 79 characters)
wedding20.py:54:80: E501 line too long (98 > 79 characters)
wedding20.py:56:80: E501 line too long (143 > 79 characters)
wedding20.py:57:56: E231 missing whitespace after ','
wedding20.py:57:80: E501 line too long (196 > 79 characters)
wedding20.py:58:80: E501 line too long (180 > 79 characters)
wedding20.py:59:80: E501 line too long (100 > 79 characters)
wedding20.py:59:101: W291 trailing whitespace
wedding20.py:61:80: E501 line too long (168 > 79 characters)
wedding20.py:62:80: E501 line too long (93 > 79 characters)
wedding20.py:65:1: W293 blank line contains whitespace
wedding20.py:66:4: E271 multiple spaces after keyword
wedding20.py:66:34: E231 missing whitespace after ','
wedding20.py:67:3: E111 indentation is not a multiple of 4
wedding20.py:68:3: E111 indentation is not a multiple of 4
wedding20.py:69:17: E231 missing whitespace after ','
wedding20.py:69:30: E231 missing whitespace after ','
wedding20.py:70:3: E111 indentation is not a multiple of 4
wedding20.py:71:17: E231 missing whitespace after ','
wedding20.py:71:24: E231 missing whitespace after ','
wedding20.py:76:1: E303 too many blank lines (4)
wedding20.py:77:3: E111 indentation is not a multiple of 4
wedding20.py:78:3: E111 indentation is not a multiple of 4
wedding20.py:79:3: E111 indentation is not a multiple of 4
wedding20.py:81:3: E111 indentation is not a multiple of 4
wedding20.py:82:3: E111 indentation is not a multiple of 4
wedding20.py:84:3: E111 indentation is not a multiple of 4
wedding20.py:85:3: E111 indentation is not a multiple of 4
wedding20.py:87:3: E111 indentation is not a multiple of 4
wedding20.py:88:3: E111 indentation is not a multiple of 4
wedding20.py:90:3: E111 indentation is not a multiple of 4
wedding20.py:91:3: E111 indentation is not a multiple of 4
wedding20.py:93:3: E111 indentation is not a multiple of 4
wedding20.py:94:3: E111 indentation is not a multiple of 4
wedding20.py:96:3: E111 indentation is not a multiple of 4
wedding20.py:97:3: E111 indentation is not a multiple of 4
wedding20.py:99:3: E111 indentation is not a multiple of 4
wedding20.py:100:3: E111 indentation is not a multiple of 4
wedding20.py:102:3: E111 indentation is not a multiple of 4
wedding20.py:103:3: E111 indentation is not a multiple of 4
wedding20.py:104:3: E111 indentation is not a multiple of 4
wedding20.py:105:3: E111 indentation is not a multiple of 4
wedding20.py:109:1: E303 too many blank lines (3)
wedding20.py:111:3: E111 indentation is not a multiple of 4
wedding20.py:119:3: E111 indentation is not a multiple of 4
wedding20.py:120:3: E111 indentation is not a multiple of 4
wedding20.py:121:12: E225 missing whitespace around operator
wedding20.py:123:7: E111 indentation is not a multiple of 4
wedding20.py:123:12: E275 missing whitespace after keyword
wedding20.py:123:12: E703 statement ends with a semicolon
wedding20.py:125:7: E111 indentation is not a multiple of 4
wedding20.py:127:7: E111 indentation is not a multiple of 4
wedding20.py:128:7: E111 indentation is not a multiple of 4
wedding20.py:129:7: E111 indentation is not a multiple of 4
wedding20.py:129:21: E703 statement ends with a semicolon
wedding20.py:131:7: E111 indentation is not a multiple of 4
wedding20.py:131:13: E231 missing whitespace after ','
wedding20.py:131:18: E231 missing whitespace after ','
wedding20.py:131:36: E231 missing whitespace after ','
wedding20.py:131:47: E231 missing whitespace after ','
wedding20.py:132:7: E111 indentation is not a multiple of 4
wedding20.py:133:7: E111 indentation is not a multiple of 4
wedding20.py:135:7: E111 indentation is not a multiple of 4
wedding20.py:135:13: E231 missing whitespace after ','
wedding20.py:136:7: E111 indentation is not a multiple of 4
wedding20.py:136:28: E703 statement ends with a semicolon
wedding20.py:137:7: E111 indentation is not a multiple of 4
wedding20.py:137:37: E703 statement ends with a semicolon
wedding20.py:139:7: E111 indentation is not a multiple of 4
wedding20.py:139:13: E231 missing whitespace after ','
wedding20.py:139:18: E231 missing whitespace after ','
wedding20.py:139:23: E231 missing whitespace after ','
wedding20.py:139:27: E221 multiple spaces before operator
wedding20.py:139:41: E231 missing whitespace after ','
wedding20.py:139:52: E231 missing whitespace after ','
wedding20.py:139:66: E231 missing whitespace after ','
wedding20.py:140:7: E111 indentation is not a multiple of 4
wedding20.py:141:7: E111 indentation is not a multiple of 4
wedding20.py:142:1: W293 blank line contains whitespace
wedding20.py:145:3: E111 indentation is not a multiple of 4
wedding20.py:145:9: W292 no newline at end of file




import itertools as it


class Wedding:
    def __init__(self):
        pass

    def panel(self, word):  # panel method (assume boundary at start) ex: abc
        if len(word) > 1:
            nminus2 = word[0]  # first letter ex: a
            # first 2 letter combination ex. ['ab','ba']
            nminus1 = [word[:2], word[1] + word[0]]
            nm1_calc = []
            nm2_calc = []

            for i in range(
                    2, len(word)):  # calculate n-1 and n2 from 3rd letter and on
                nm1_calc = [x + word[i] for x in nminus1]
                nm2_calc = [x + word[i] + word[i - 1] for x in nminus2]
                nminus2 = nminus1  # new n-2 is previous n-1
                nminus1 = nm1_calc + nm2_calc  # new n-1 is newly calulated n-1 and n-2
        else:  # if it's one letter or empty word return the word itself
            nminus1 = [word]

        return (nminus1)  # n-1 contains final list

    def shuffle(self, word):  # method has no boundaries
        if len(word) > 2:  # example 'abcd'
            # assume a doesn't swap, -> a + panel('bcd')
            comb_stay = self.panel(word[1:])
            # assume a swaps with b -> ba + panel('cd')
            comb_shiftrt = self.panel(word[2:])
            # assume a swaps with d -> d+panel('bc')+a
            comb_shiftlt = self.panel(word[1:len(word) - 1])
            # adds a to combinations
            comb_stay_form = [word[0] + i for i in comb_stay]
            # adds ba to the combinations
            comb_shiftrt_form = [word[1] + word[0] + i for i in comb_shiftrt]
            comb_shiftlt_form = [word[-1] + i + word[0] for i in
                                 comb_shiftlt]  # adds da based on location to the combinations
            # shift all letters one right
            rotate_rt = [word[-1] + word[:len(word) - 1]]
            rotate_lt = [word[1:] + word[0]]  # shift all letters one left
            comb_final = comb_stay_form + comb_shiftrt_form + comb_shiftlt_form + \
                rotate_rt + rotate_lt  # add all combinations together
        else:  # if 2 letter word or less, return word combination using panel method
            comb_final = self.panel(word)
        return comb_final

    def barriers(self, word, block):  # methods has more than boudaries at any location
        new_word = []
        comb = []
        combf_join = []

        if len(
                block) < 1:  # if block is not provided then trat it like word with no boundaries
            comb_format = self.shuffle(word)
        else:
            for i in range(len(block)):  # example: 'A|bc|d|EF'
                if i < len(
                        # separate word based on the location of the block ->
                        # new_word = ['bc','d']
                        block) - 1:
                    new_word += [word[block[i]:block[i + 1]]]
                # when you reach last block, include remaining letter ->
                # new_word = ['EFA']
                else:
                    new_word += [word[block[i]:] + word[:block[0]]]
                # perform panel on all of the new words
                comb = [self.panel(i) for i in new_word]
                # rem1 = comb
                for i in range(
                        len(comb) - 1):  # multiply two word combinations together aand then multiply that with the next word combination
                    comb[i + 1] = list(it.product(comb[i], comb[
                        i + 1]))  # use itertools product method to multiply each words' combinations with each other and store combination at the same location
                    comb[i + 1] = [j[0] + '|' + j[1] for j in comb[
                        i + 1]]  # for each combinations join parts together and include '|' to identify the wall; the final multiplied combina
                if 0 in block:  # if there is a boundary at 0th position include '|' at the start
                    comb_format = ['|' + i[:len(i) - block[0]]
                                   for i in comb[-1]]
                else:  # otherwise shift the word back to it's original position based and add '|' at teh first block location -> 'bc|d|EFA' changes to 'A|bc|d|EF'
                    comb_format = [i[-1 * block[0]:] + '|' +
                                   i[:len(i) - block[0]] for i in comb[-1]]
        return comb_format


def show_result(v, partial=False, ind=None):
    v.sort()
    if not partial:
        print(len(v), "\n".join(v), sep="\n")
    else:
        print(len(v), v[ind], sep="\n")


def standard_tests():
    standard = Wedding()
    res = standard.shuffle("abc")
    show_result(res)

    res = standard.shuffle("WXYZ")
    show_result(res)

    res = standard.barriers("xyz", [0])
    show_result(res)

    res = standard.shuffle("abc")
    show_result(res)

    res = standard.shuffle("abcdefXY")
    show_result(res)

    res = standard.barriers("abcDEFxyz", [2, 5, 7])
    show_result(res)

    res = standard.barriers("ABCDef", [4])
    show_result(res)

    res = standard.barriers("bgywqa", [0, 1, 2, 4, 5])
    show_result(res)

    res = standard.barriers("n", [0])
    show_result(res)
    res = standard.shuffle("hi")
    show_result(res)


def main():
    print("""Type quit to exit.
Commands:
tests
s guests
b guests n barriers
sp guests ind
bp guests n barriers ind
""")
    w = Wedding()
    while True:
        asktype = input().split()
        if not asktype or asktype[0] == "quit":
            break
        elif asktype[0] == "tests":
            standard_tests()
        elif asktype[0] == "s":
            guests = asktype[1]
            r = w.shuffle(guests)
            show_result(r)
        elif asktype[0] == "b":
            guests, nbar, bars = asktype[1], asktype[2], asktype[3:]
            r = w.barriers(guests, [int(x) for x in bars])
            show_result(r)
        elif asktype[0] == "sp":
            guests, ind = asktype[1:]
            r = w.shuffle(guests)
            show_result(r, True, int(ind))
        elif asktype[0] == "bp":
            guests, nbar, bars, ind = asktype[1], asktype[2], asktype[3:-1], asktype[-1]
            r = w.barriers(guests, [int(x) for x in bars])
            show_result(r, True, int(ind))


if __name__ == '__main__':
    main()

